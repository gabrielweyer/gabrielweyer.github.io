I"ä*<p>Iâ€™m continuing to read the excellent <a href="https://www.goodreads.com/book/show/7306509-advanced-net-debugging">Advanced .NET Debugging</a> by Mario Hewardt. Last time I looked at <a href="/2018/04/06/advanced-dotnet-debugging-1/">finding the entry point of a native image</a>. This time around Iâ€™ll be investigating the launch of a <strong>managed</strong> image by <code class="language-plaintext highlighter-rouge">Windows</code>.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
  <li>A hex viewer
    <ul>
      <li>I used the <a href="https://peclrviewer.azurewebsites.net/">PE CLR Viewer</a> (<strong>disclaimer</strong>: I created this truly ugly looking website)<!--more--></li>
    </ul>
  </li>
</ul>

<h2 id="the-problem">The problem</h2>

<p>In the section <strong>Loading .NET Assemblies</strong> Mario explains how <code class="language-plaintext highlighter-rouge">Windows</code> is loading a managed image. Heâ€™s leveraging <a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference">dumpbin.exe</a> which requires a <code class="language-plaintext highlighter-rouge">Visual Studio</code> installation <strong>with</strong> the <code class="language-plaintext highlighter-rouge">C++</code> workload. This has two issues:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">C++</code> workload requires a few <code class="language-plaintext highlighter-rouge">GB</code> of hard drive</li>
  <li><code class="language-plaintext highlighter-rouge">dumpbin</code> presents a high-level view of the different headers, hence itâ€™s not a good teaching tool as it abstracts the process of reading the bytes</li>
</ul>

<p>I decided to try a different approach. Iâ€™ve compiled a <strong>x86</strong> managed image which you can download <a href="https://gabrielweyer.blob.core.windows.net/blog-samples/advanced-dotnet-debugging-2/net461-x86.exe">here</a>. You can then visualise it using the <a href="https://peclrviewer.azurewebsites.net/">PE CLR Viewer</a> and follow me down the rabbit hole.</p>

<h2 id="finding-the-addressofentrypoint">Finding the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code></h2>

<p>I recommend you first read the <a href="/2018/04/06/advanced-dotnet-debugging-1/">previous post</a> in this series as it explains core concepts such as <a href="/2018/04/06/advanced-dotnet-debugging-1/#endianness">endianness</a> and <a href="/2018/04/06/advanced-dotnet-debugging-1/#relative-virtual-address">Relative Virtual Address</a>.</p>

<p>Last time I highlighted a formula to compute the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> file offset:</p>

<blockquote>
  <p>Signature file offset + <code class="language-plaintext highlighter-rouge">0x28</code> = <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> file offset</p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">signature file offset</code> is always at file offset <code class="language-plaintext highlighter-rouge">0x3C</code>. As seen below it has for value <code class="language-plaintext highlighter-rouge">0x80</code>.</p>

<p><img src="/assets/advanced-dotnet-debugging-2/signature-file-offset.png" alt="Signature file offset" /></p>

<p>Now that we have the <code class="language-plaintext highlighter-rouge">signature file offset</code>, we can compute the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> file offset:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">0x80</code> + <code class="language-plaintext highlighter-rouge">0x28</code> = <code class="language-plaintext highlighter-rouge">0xA8</code></p>
</blockquote>

<p><img src="/assets/advanced-dotnet-debugging-2/address-of-entry-point.png" alt="AddressOfEntryPoint" /></p>

<p>As seen above, <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> has for value <code class="language-plaintext highlighter-rouge">0x2716</code>. But wait weâ€™re not done, the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> is a <code class="language-plaintext highlighter-rouge">RVA</code> which we need to convert to a file offset.</p>

<h2 id="converting-the-entry-point-rva-to-a-file-offset">Converting the entry point <code class="language-plaintext highlighter-rouge">RVA</code> to a file offset</h2>

<p>The entry point is located in the <strong>.text</strong> section (the <strong>.text</strong> section contains executable code), so weâ€™ll need to locate the <strong>.text</strong> section first and this is where the <strong>section headers</strong> come into play. The <strong>section headers</strong> is a conversion table between <code class="language-plaintext highlighter-rouge">RVA</code> and file offset for the different sections:</p>

<p><img src="/assets/advanced-dotnet-debugging-2/text-section-header.png" alt=".text section header" /></p>

<p>According to the screenshot above the <strong>.text</strong> section has a base <code class="language-plaintext highlighter-rouge">RVA</code> of <code class="language-plaintext highlighter-rouge">0x2000</code> and is located at file offset <code class="language-plaintext highlighter-rouge">0x200</code>. Those two pieces of information will allow us to convert the entry point <code class="language-plaintext highlighter-rouge">RVA</code> into an entry point file offset:</p>

<blockquote>
  <p>Entry point <code class="language-plaintext highlighter-rouge">RVA</code> - .text base <code class="language-plaintext highlighter-rouge">RVA</code> + .text file offset = entry point file offset</p>
</blockquote>

<p>Letâ€™s replace the placeholders with the values we obtained previously:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">0x2716</code> - <code class="language-plaintext highlighter-rouge">0x2000</code> + <code class="language-plaintext highlighter-rouge">0x200</code> = <code class="language-plaintext highlighter-rouge">0x916</code></p>
</blockquote>

<p>The entry point has for file offset <code class="language-plaintext highlighter-rouge">0x916</code>. But as weâ€™ll see in the next section, this is yet another level of indirection.</p>

<h2 id="jumping-into-the-import-address-table">Jumping into the Import Address Table</h2>

<p><img src="/assets/advanced-dotnet-debugging-2/jump.png" alt="JMP" /></p>

<p>Apparently the first part (<code class="language-plaintext highlighter-rouge">FF25</code>) is the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x86-instructions#control_flow">x86 instruction</a> for <code class="language-plaintext highlighter-rouge">JMP</code> which instruct the computer to jump to an address (the second part):</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">JMP 402000</code></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">0x402000</code> is a <code class="language-plaintext highlighter-rouge">VA</code> (<code class="language-plaintext highlighter-rouge">Virtual Address</code>) based on the <strong>image base</strong> which has a value of <code class="language-plaintext highlighter-rouge">0x400000</code> (as seen in the <strong>NT specific fields header</strong> section):</p>

<p><img src="/assets/advanced-dotnet-debugging-2/image-base.png" alt="Image Base" /></p>

<p>Armed with this knowledge we can convert the <code class="language-plaintext highlighter-rouge">VA</code> to a <code class="language-plaintext highlighter-rouge">RVA</code>:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">VA</code> - image base <code class="language-plaintext highlighter-rouge">VA</code> = <code class="language-plaintext highlighter-rouge">RVA</code></p>
</blockquote>

<p>Letâ€™s replace the placeholders with the values we obtained previously:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">0x402000</code> - <code class="language-plaintext highlighter-rouge">0x400000</code> = <code class="language-plaintext highlighter-rouge">0x2000</code></p>
</blockquote>

<p>If we look at the <strong>Data directories</strong> section, we can see than the <strong>Import Address Table</strong> is located at <code class="language-plaintext highlighter-rouge">RVA</code> <code class="language-plaintext highlighter-rouge">0x2000</code>. The <strong>Import Address Table</strong> is the first section of the <strong>.text</strong> section.</p>

<p><img src="/assets/advanced-dotnet-debugging-2/import-address-table-rva.png" alt="Import Address Table RVA" /></p>

<h2 id="jumping-out-of-the-import-address-table">Jumping out of the Import Address Table</h2>

<p><img src="/assets/advanced-dotnet-debugging-2/import-address-table.png" alt="Import Address Table" /></p>

<p>The <code class="language-plaintext highlighter-rouge">RVA</code> located at file offset <code class="language-plaintext highlighter-rouge">0x200</code> is: <code class="language-plaintext highlighter-rouge">0x26F8</code>. Like a mad rabbit, we continue jumping around. We can reuse the formula to convert a <code class="language-plaintext highlighter-rouge">RVA</code> to a file offset:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">0x26F8</code> - <code class="language-plaintext highlighter-rouge">0x2000</code> + <code class="language-plaintext highlighter-rouge">0x200</code> = <code class="language-plaintext highlighter-rouge">0x8F8</code></p>
</blockquote>

<p>Now I have good news, <code class="language-plaintext highlighter-rouge">0x8F8</code> is our final destination. Letâ€™s inspect it more closely:</p>

<p><img src="/assets/advanced-dotnet-debugging-2/real-entry-point.png" alt="Real entry point" /></p>

<p>We skip the leading <code class="language-plaintext highlighter-rouge">NUL</code> bytes, the other bytes are <code class="language-plaintext highlighter-rouge">ASCII</code> characters. The first section is the function name <code class="language-plaintext highlighter-rouge">_CorExeMain</code> and - coming after a <code class="language-plaintext highlighter-rouge">NUL</code> byte - the second section is the name of the executable: <code class="language-plaintext highlighter-rouge">mscoree.dll</code>.</p>

<p>As it turns out <code class="language-plaintext highlighter-rouge">mscoree.dll</code> is located in the <code class="language-plaintext highlighter-rouge">Windows</code> directory:</p>

<p><img src="/assets/advanced-dotnet-debugging-2/mscoree.png" alt="mscoree" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>Iâ€™ve demonstrated how to find the entry point of a <strong>x86</strong> managed image but in reality <code class="language-plaintext highlighter-rouge">Windows</code> knows how to execute a managed image just by looking at the <strong>CLI header</strong>. In the case of <strong>x64</strong> managed image the entry point is not even present!</p>

:ET
I"Ç#<p>Another day, another â€œinterestingâ€ issue at a customer. After deploying our product we were left with a partially working web application. The productÂ has been developed over many years and is a mix of ASP Classic, Web Forms, MVC and Web API.Â In this case ASP Classic pages were broken and would throw an error.</p>

<h2 id="ensuring-asp-classic-is-configured-properly">Ensuring ASP Classic is configured properly</h2>

<p>The first step is to ensure that IIS has been configured to execute ASP Classic andÂ this is done easily by adding a dummyÂ ASP page to the web application. After deploying this page I was able to confirm that itÂ was working as expected.</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/5eb3198119bead02649c0fe11d733055.js"> </script>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/dummy-asp.png" alt="dummy-asp" /><!--more--></p>

<h2 id="enabling-failed-request-tracing">Enabling failed request tracing</h2>

<p>The features written in ASP Classic have been written many years ago and the developers didnâ€™t consider logging as a key part of the development process. The end result being that when something goes wrong no logs get written by the application or to the event viewer.</p>

<p>The second step is to turn on the â€œ<strong>Failed Request Tracing Rules</strong>â€œÂ and reload the failing page. Internet has a lot of tutorials around this but theyâ€™re all missing key steps, Iâ€™ll focus on those as you can find everything else easily.</p>

<p>â€œFailed Request Tracing Rulesâ€ will not be available in the IIS Manager if you didnâ€™t turn on the <strong>Tracing</strong> feature in Windows Features:</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/tracing.png" alt="tracing" /></p>

<p>Another thing is that multiple sites could be writing traces at the same time. Each site will be writing to a different sub folder suffixed with the site ID:</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/site-id.gif" alt="site-id" /></p>

<p>Finally you can copy the log files back to your machine, donâ€™t forget to copy the freb.xsl file too, youâ€™ll then be able to open the XML files in Internet Explorer and look at a human readable representation of the log.</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/invalid-authority.png" alt="invalid-authority" /></p>

<p>All ASP Classic pages are calling an API endpoint in order to get a tokenÂ (long story short: donâ€™t ask - the user is signing-in in an AngularJS app backed by Web API and is then able to use seamlessly the pages hosted on MVC, Web Forms and Classic ASP). What is strange in this situation is that Internet Explorer is marking the TLS certificate as valid, so does Chrome. Even worse: the same ASP Classic page hosted on my machine calling the token endpoint on the remote server is successful! The Windows Certificate Manager is displaying the same message for the root CA, intermediate CA and certificate:Â â€This certificate is OK.â€.</p>

<p>I then suspected theÂ certificate might be using unsupported ciphers but it turned out that it wasnâ€™t the case. I quickly wroteÂ a C# Console application calling the same token endpoint - the HttpClient class is throwing meaningful errors - but to my dismay the C# code was able to call the endpoint successfully!</p>

<p>Armed with the ErrorCode â€œ80072f0dâ€ and the Description â€œThe certificate authority is invalid or incorrectâ€ I scoured Internet for some potential solutions. Everything I could find was related to invalid and self-signed certificates.</p>

<h2 id="capturing-packets-on-a-windows-server">Capturing packets on a Windows Server</h2>

<p>When people think â€œpacket captureâ€ they always assume they need to install <a href="https://www.wireshark.org/">Wireshark</a> (or another similar tool) whereas Windows Server is shipping with the ability to capture network packets with <a href="https://technet.microsoft.com/en-us/library/dd878517(v=ws.10).aspx">netsh</a> since Windows Server 2008 R2. The advantage of this solution is that you donâ€™t need to install anything on the machine. To see if itâ€™s available, all you need to do is open a command prompt and type:</p>

<figure class="highlight"><pre><code class="language-posh" data-lang="posh"><span class="nf">netsh</span><span class="w"> </span><span class="nx">trace</span></code></pre></figure>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/netsh-trace.gif" alt="netsh-trace" /></p>

<p>Now that we know that <strong>trace</strong> is available we need to start capturing the packets and reproduce the problem. Launch an <strong>elevated</strong> command prompt and type:</p>

<figure class="highlight"><pre><code class="language-posh" data-lang="posh"><span class="nf">netsh</span><span class="w"> </span><span class="nx">trace</span><span class="w"> </span><span class="nx">start</span><span class="w"> </span><span class="nx">tracefile</span><span class="o">=</span><span class="s2">"C:\tmp\traces\classic.etl"</span><span class="w"> </span><span class="nf">scenario</span><span class="o">=</span><span class="nf">internetclient</span><span class="w"> </span><span class="nx">capture</span><span class="o">=</span><span class="nf">yes</span><span class="w"> </span><span class="nx">maxsize</span><span class="o">=</span><span class="mi">200</span><span class="w"> </span><span class="nf">filemode</span><span class="o">=</span><span class="nf">circular</span><span class="w"> </span><span class="nx">overwrite</span><span class="o">=</span><span class="nf">yes</span></code></pre></figure>

<p><strong>Note</strong>: the path needs to exist beforehand.</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/start-stop.gif" alt="start-stop" /></p>

<p>Starting and stopping the trace is actually slower that what is demonstrated above but I didnâ€™t want lo lose your attention! And of course you would need to reproduce the issueÂ before issuing:</p>

<figure class="highlight"><pre><code class="language-posh" data-lang="posh"><span class="nf">netsh</span><span class="w"> </span><span class="nx">stop</span></code></pre></figure>

<h2 id="microsoft-message-analyzer">Microsoft Message Analyzer</h2>

<p>We now need to analyze this trace and this is done with the <a href="https://technet.microsoft.com/en-us/library/jj649776.aspx">Microsoft Message</a> <a href="https://blogs.technet.microsoft.com/messageanalyzer/">Analyzer</a> (can be downloaded <a href="https://www.microsoft.com/en-au/download/details.aspx?id=44226">here</a>). The Analyzer takes a long time to open the smallest trace but once the trace is loaded you can search quickly.</p>

<p>Weâ€™ll first look for an HTTP CONNECT, use this filter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(HTTP.Method == "CONNECT") And
(HTTP.Uri.Host == "domain.name") And
(HTTP.Uri.Port == "port")
</code></pre></div></div>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/connect.png" alt="connect.png" /></p>

<p>As we can see the CONNECT was successful. Letâ€™s investigate the TLS handshake now, this is handled by the TLS module so all we need to do is filter on this module only:</p>

<blockquote>
  <p>TLS</p>
</blockquote>

<p>This is what was captured when the C# application connected to the token endpoint:</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/c-sharp-tls.png" alt="c-sharp-tls" /></p>

<p>This is matching closely what is described in the <a href="https://tools.ietf.org/html/rfc5246#page-36">RFC 5246</a> (TLS 1.2).</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/full-handshake.png" alt="full-handshake" /></p>

<p>Letâ€™s now capture the traffic when the VB code is trying to call the token endpoint.</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/vb-tls.png" alt="vb-tls.png" /></p>

<p>Great Scott! The server is sending <code class="language-plaintext highlighter-rouge">ServerHello</code> as expected but the client doesnâ€™t reply with <code class="language-plaintext highlighter-rouge">ClientKeyExchange</code>.Â I then removed the filter and started to look at the messages below. My reasoning was that I should be finding some kind of error message soon after and here it was:</p>

<p><img src="/assets/2016-07-16-capture-network-packets-with-netsh/browsing-messages.png" alt="browsing-messages" /></p>

<p>The error message was:</p>

<blockquote>
  <p>A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider. (0x800B0109)</p>
</blockquote>

<p>As it turned out someone had messed up with the certificate store and removed the intermediate CAÂ from the â€œIntermediate Certification Authoritiesâ€. As the root CA was still present in the â€œTrusted Root Certification Authoritiesâ€ it was good enough for Internet Explorer and C# but it wasnâ€™t for VB! I added the intermediate CA to the store and things started to work again.</p>

:ET
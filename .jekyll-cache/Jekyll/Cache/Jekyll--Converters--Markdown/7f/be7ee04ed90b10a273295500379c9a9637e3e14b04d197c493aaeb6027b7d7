I"qÑ<p><strong>30th of Jan 2022</strong>: Many .NET open-source have now migrated to <a href="https://docs.github.com/en/actions">GitHub Actions</a>. I hence decided to include it in this post.</p>

<p><strong>25th of Sep 2021</strong>: I decided to remove Travis CI from this post. Travis CI recently <a href="https://www.theregister.com/2021/09/15/travis_ci_leak/">poorly handled a security vulnerability</a> and security is of paramount importance when it comes to build systems.</p>

<p><strong>5th of Jan 2019</strong>: a lot has been happening since I initially wrote this post. <code class="language-plaintext highlighter-rouge">Azure DevOps</code> released a free tier for open source projects, the <code class="language-plaintext highlighter-rouge">Cake</code> and <code class="language-plaintext highlighter-rouge">GitVersion</code> contributors have been hard at work to take advantage of the latest features of <code class="language-plaintext highlighter-rouge">.NET Core</code>. So many things have changed that I decided to update this post to reflect the current state of affairs (inclusion of <code class="language-plaintext highlighter-rouge">Azure DevOps</code>, upgrade to <code class="language-plaintext highlighter-rouge">.NET Core 2.2</code>, utilisation of <code class="language-plaintext highlighter-rouge">.NET Core global tools</code> and removing the <code class="language-plaintext highlighter-rouge">Mono</code> requirement on <code class="language-plaintext highlighter-rouge">Unix</code> platforms).</p>

<p>As a developer I‚Äôm amazed by the number of free tools and services available. I wanted to create an end-to-end demo of a <code class="language-plaintext highlighter-rouge">CI/CD</code> pipeline that would include:</p>

<ul>
  <li><a href="/2018/04/21/cake-build/#configuration">Trigger a build on commit</a></li>
  <li><a href="/2018/04/21/cake-build/#semantic-versioning">Use semantic versioning</a></li>
  <li><a href="/2018/04/21/cake-build/#run-the-tests">Run tests</a></li>
  <li><a href="/2018/04/21/cake-build/#publish-the-test-results">Publish test results</a></li>
  <li><a href="/2018/04/21/cake-build/#create-nuget-packages">Create NuGet packages</a></li>
  <li><a href="/2018/04/21/cake-build/#publish-the-nuget-packages">Publish the NuGet packages</a></li>
  <li><a href="/2018/04/21/cake-build/#create-a-github-release">Create a GitHub release</a></li>
</ul>

<p>For my purpose I wanted anonymous users to have access to a read-only view. <a href="https://www.appveyor.com/">AppVeyor</a> and <a href="https://docs.github.com/en/actions">GitHub Actions</a> are the most popular choices for <code class="language-plaintext highlighter-rouge">.NET</code> open-source projects. <a href="https://circleci.com/">CircleCI</a> seems to have dropped in popularity. <a href="https://azure.microsoft.com/en-au/services/devops/">Azure DevOps</a> released (and then <a href="https://devblogs.microsoft.com/devops/change-in-azure-pipelines-grant-for-public-projects/">unreleased</a>) a free and unlimited plan for open source projects. As I had both CircleCI and Azure DevOps working, I decided to keep them. In this post I‚Äôll be leveraging the four platforms so that I can highlight their pros and cons.<!--more--></p>

<h2 id="configuration">Configuration</h2>

<p>The code is hosted on the <code class="language-plaintext highlighter-rouge">GitHub</code> repository <a href="https://github.com/gabrielweyer/cake-build">Cake build</a> and is using <a href="https://cakebuild.net/">Cake</a> as its build system.</p>

<p><code class="language-plaintext highlighter-rouge">AppVeyor</code>, <code class="language-plaintext highlighter-rouge">Azure DevOps</code>, <code class="language-plaintext highlighter-rouge">CircleCI</code> and <code class="language-plaintext highlighter-rouge">GitHub Actions</code> all use <a href="https://yaml.org/">YAML</a> configuration files. This means that your build steps are living in the same space than your code and this presents several benefits:</p>

<ul>
  <li>Any developer can modify the build</li>
  <li>The project is self-contained
    <ul>
      <li>Developers don‚Äôt have to search where the build is located</li>
      <li>It doesn‚Äôt matter if something terrible happens to the build server</li>
    </ul>
  </li>
  <li>Ability to run the build locally on some platforms</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">YAML</code> files are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AppVeyor</code>: <a href="https://github.com/gabrielweyer/cake-build/blob/main/appveyor.yml">appveyor.yml</a></li>
  <li><code class="language-plaintext highlighter-rouge">Azure DevOps</code>: <a href="https://github.com/gabrielweyer/cake-build/blob/main/azure-pipelines.yml">azure-pipelines.yml</a></li>
  <li><code class="language-plaintext highlighter-rouge">CircleCI</code>: <a href="https://github.com/gabrielweyer/cake-build/blob/main/.circleci/config.yml">.circleci/config.yml</a></li>
  <li><code class="language-plaintext highlighter-rouge">GitHub Actions</code>: <a href="https://github.com/gabrielweyer/cake-build/blob/main/.github/workflows/build.yml">.github/workflows/build.yml</a></li>
</ul>

<h2 id="the-code">The code</h2>

<p>The project is useless. What is important is that it describes a real-life scenario:</p>

<ul>
  <li>The solution contains two projects which will be packed as <code class="language-plaintext highlighter-rouge">NuGet</code> packages
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">Logic</code> project references a <code class="language-plaintext highlighter-rouge">NuGet</code> package from <a href="https://www.nuget.org/">nuget.org</a> via a <code class="language-plaintext highlighter-rouge">PackageReference</code>, <code class="language-plaintext highlighter-rouge">dotnet pack</code> will turn this into a package reference.</li>
      <li>The <code class="language-plaintext highlighter-rouge">SuperLogic</code> project depends on <code class="language-plaintext highlighter-rouge">Logic</code> and when packing, this project reference will be turned into a <code class="language-plaintext highlighter-rouge">NuGet</code> package reference (handled out of the box by <code class="language-plaintext highlighter-rouge">dotnet pack</code>)</li>
    </ul>
  </li>
  <li>The projects target both <code class="language-plaintext highlighter-rouge">nestandard2.0</code> and <code class="language-plaintext highlighter-rouge">net461</code> so they can also be used with the <code class="language-plaintext highlighter-rouge">.NET Framework</code> (<code class="language-plaintext highlighter-rouge">net461</code> and above)
    <ul>
      <li>The resulting <code class="language-plaintext highlighter-rouge">NuGet</code> packages should contain <code class="language-plaintext highlighter-rouge">DLL</code>s for both frameworks</li>
    </ul>
  </li>
  <li>The projects reference a third project that should be embedded as a <code class="language-plaintext highlighter-rouge">DLL</code> rather than being referenced as a <code class="language-plaintext highlighter-rouge">NuGet</code> package
    <ul>
      <li>This is not yet supported by the new tooling but can be <a href="#create-nuget-packages">achieved</a>.</li>
    </ul>
  </li>
</ul>

<h2 id="pinning-cake-version">Pinning <code class="language-plaintext highlighter-rouge">Cake</code> version</h2>

<p>Pinning the version of <code class="language-plaintext highlighter-rouge">Cake</code> guarantees you‚Äôll be using the same version of <code class="language-plaintext highlighter-rouge">Cake</code> on your machine and on the build servers. This is achieved by installing Cake as a <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/local-tools-how-to-use">.NET local tool</a>.</p>

<h2 id="semantic-versioning">Semantic versioning</h2>

<p>As I‚Äôm releasing packages I decided to use <a href="https://semver.org/">semantic versioning</a>.</p>

<blockquote>
  <p>Consider a version format of <code class="language-plaintext highlighter-rouge">X.Y.Z</code> (<code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code>). Bug fixes not affecting the API increment the <strong>patch</strong> version, backwards compatible API additions/changes increment the <strong>minor</strong> version, and backwards incompatible API changes increment the <strong>major</strong> version.</p>
</blockquote>

<p>Semantic versioning allows the consumers of your binaries to assess the effort to upgrade to a newer version. Semantic versioning should not be used blindly for all kinds of projects. It makes a lot of sense for a <code class="language-plaintext highlighter-rouge">NuGet</code> package but it doesn‚Äôt for a product or an <code class="language-plaintext highlighter-rouge">API</code> for example.</p>

<h3 id="versioning-in-net">Versioning in <code class="language-plaintext highlighter-rouge">.NET</code></h3>

<p>In <code class="language-plaintext highlighter-rouge">.NET</code> we use four properties to handle versioning:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssemblyVersion</code>, <code class="language-plaintext highlighter-rouge">AssemblyFileVersion</code> and <code class="language-plaintext highlighter-rouge">AssemblyInformationalVersion</code> to version assemblies</li>
  <li><code class="language-plaintext highlighter-rouge">PackageVersion</code> to version a <code class="language-plaintext highlighter-rouge">NuGet</code> package</li>
</ul>

<h4 id="versioning-an-assembly">Versioning an assembly</h4>

<p><a href="https://stackoverflow.com/a/65062">These</a> <a href="https://stackoverflow.com/a/802038">two</a> <code class="language-plaintext highlighter-rouge">StackOverflow</code> answers are great at explaining how to version an assembly.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssemblyVersion</code>: the only version the <code class="language-plaintext highlighter-rouge">CLR</code> cares about (if you use <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/strong-named-assemblies">strong named assemblies</a>)</li>
</ul>

<p>Curiously enough the <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/assembly-versioning#assembly-version-number">official documentation</a> is sparse on the <a href="https://blogs.msdn.microsoft.com/msbuild/2007/01/03/why-are-build-numbers-limited-to-65535/">topic</a> but this what I came up with after doing some reading:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">AssemblyVersion</code> can be defined as <code class="language-plaintext highlighter-rouge">&lt;major-version&gt;.&lt;minor-version&gt;.&lt;build-number&gt;.&lt;revision&gt;</code> where each of the four segment is a <code class="language-plaintext highlighter-rouge">16-bit</code> unsigned number.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssemblyInformationalVersion</code>: <code class="language-plaintext highlighter-rouge">string</code> that attaches additional version information to an assembly for informational purposes only. Corresponds to the product‚Äôs marketing literature, packaging, or product name</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">AssemblyInformationalVersion</code> is well <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/assembly-versioning#assembly-informational-version">documented</a>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssemblyFileVersion</code>: intended to uniquely identify a build of the individual assembly</li>
</ul>

<p>Developers tend to auto-increment this on each build. I prefer it linked to a <code class="language-plaintext highlighter-rouge">commit</code> / <code class="language-plaintext highlighter-rouge">tag</code> to be able to reproduce a build. I also use the same <code class="language-plaintext highlighter-rouge">string</code> for <code class="language-plaintext highlighter-rouge">AssemblyInformationalVersion</code> and <code class="language-plaintext highlighter-rouge">AssemblyFileVersion</code> (I‚Äôm a bad person I know).</p>

<h4 id="versioning-a-nuget-package">Versioning a <code class="language-plaintext highlighter-rouge">NuGet</code> package</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PackageVersion</code>: A specific package is always referred to using its package identifier and an exact version number</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">NuGet</code> package versioning is described <a href="https://docs.microsoft.com/en-us/nuget/reference/package-versioning">here</a>.</p>

<h3 id="gitversion"><code class="language-plaintext highlighter-rouge">GitVersion</code></h3>

<p>I‚Äôve implemented semantic versioning using <a href="https://github.com/GitTools/GitVersion">GitVersion</a>. I recommend using <a href="https://docs.github.com/en/get-started/quickstart/github-flow">GitHub Flow</a> when working on a simple package. In my experience <a href="https://trunkbaseddevelopment.com/">Trunk Based Development</a> tends to lead to lower code quality. Developers push early and often thinking they will fix it later but we all know than in software development later means never.</p>

<p><code class="language-plaintext highlighter-rouge">GitVersion</code> produces an output that will allow you to handle even the trickiest situations:</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"Major"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"Minor"</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="nl">"Patch"</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w">
  </span><span class="nl">"PreReleaseTag"</span><span class="p">:</span><span class="s2">"region-endpoint.2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"PreReleaseTagWithDash"</span><span class="p">:</span><span class="s2">"-region-endpoint.2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"PreReleaseLabel"</span><span class="p">:</span><span class="s2">"region-endpoint"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"PreReleaseNumber"</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="nl">"BuildMetaData"</span><span class="p">:</span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"BuildMetaDataPadded"</span><span class="p">:</span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"FullBuildMetaData"</span><span class="p">:</span><span class="s2">"Branch.features/region-endpoint.Sha.1f05a4bb4ebda8b293fbd139063ce3af22b1935a"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"MajorMinorPatch"</span><span class="p">:</span><span class="s2">"0.2.3"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"SemVer"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint.2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"LegacySemVer"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"LegacySemVerPadded"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint0002"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"AssemblySemVer"</span><span class="p">:</span><span class="s2">"0.2.3.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"FullSemVer"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint.2"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"InformationalVersion"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint.2+Branch.features/region-endpoint.Sha.1f05a4bb4ebda8b293fbd139063ce3af22b1935a"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"BranchName"</span><span class="p">:</span><span class="s2">"features/region-endpoint"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"Sha"</span><span class="p">:</span><span class="s2">"1f05a4bb4ebda8b293fbd139063ce3af22b1935a"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"NuGetVersionV2"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint0002"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"NuGetVersion"</span><span class="p">:</span><span class="s2">"0.2.3-region-endpoint0002"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"CommitsSinceVersionSource"</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="nl">"CommitsSinceVersionSourcePadded"</span><span class="p">:</span><span class="s2">"0002"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"CommitDate"</span><span class="p">:</span><span class="s2">"2018-01-31"</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>In my case I‚Äôm using:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AssemblySemVer</code> as the <code class="language-plaintext highlighter-rouge">AssemblyVersion</code></li>
  <li><code class="language-plaintext highlighter-rouge">NuGetVersion</code> as the <code class="language-plaintext highlighter-rouge">AssemblyInformationalVersion</code>, <code class="language-plaintext highlighter-rouge">AssemblyFileVersion</code> and <code class="language-plaintext highlighter-rouge">PackageVersion</code></li>
</ul>

<p>If you want to handle rebasing and <code class="language-plaintext highlighter-rouge">Pull Request</code>s you‚Äôll have to use a more complex versioning strategy (keep in mind that <code class="language-plaintext highlighter-rouge">GitHub</code> advises against <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests">force-push</a> in <code class="language-plaintext highlighter-rouge">Pull Request</code>s).</p>

<p>As an aside <code class="language-plaintext highlighter-rouge">Cake</code> allows you to <a href="https://cakebuild.net/api/Cake.AppVeyor/AppVeyorBuild/069D8D3F">set</a> the <code class="language-plaintext highlighter-rouge">AppVeyor</code> build number.</p>

<p><img src="/assets/cake-build/app-veyor-version.png" alt="AppVeyor version" /></p>

<p>I do not set the <code class="language-plaintext highlighter-rouge">AppVeyor</code> build number any more as <code class="language-plaintext highlighter-rouge">GitHub Actions</code> is pushing the <code class="language-plaintext highlighter-rouge">NuGet</code> packages and creating the tags and <code class="language-plaintext highlighter-rouge">GitHub</code> releases.</p>

<h2 id="run-the-tests">Run the tests</h2>

<p>As the <code class="language-plaintext highlighter-rouge">CircleCI</code> build is running on <code class="language-plaintext highlighter-rouge">Linux</code> it doesn‚Äôt support testing against <code class="language-plaintext highlighter-rouge">net461</code>. Luckily the framework can be specified using an argument: <code class="language-plaintext highlighter-rouge">--framework net6.0</code>.</p>

<h2 id="publish-the-test-results">Publish the test results</h2>

<h3 id="appveyor">AppVeyor</h3>

<p>Again, the integration between <code class="language-plaintext highlighter-rouge">Cake</code> and <code class="language-plaintext highlighter-rouge">AppVeyor</code> shines in this area as <code class="language-plaintext highlighter-rouge">Cake</code> will automatically publish the test results for you (I wondered why I had duplicate test results until I <a href="https://en.wikipedia.org/wiki/RTFM">RTFM</a>).</p>

<p><code class="language-plaintext highlighter-rouge">AppVeyor</code> displays all the tests but you must hover to see the framework used:</p>

<p><img src="/assets/cake-build/app-veyor-test-success.png" alt="AppVeyor framework" /></p>

<p>Failed tests come with a nice formatting and a <code class="language-plaintext highlighter-rouge">StackTrace</code>:</p>

<p><img src="/assets/cake-build/app-veyor-failed-test.png" alt="AppVeyor failed test" /></p>

<h3 id="azure-devops">Azure DevOps</h3>

<p><code class="language-plaintext highlighter-rouge">Azure DevOps</code> has the most powerful tests results tab:</p>

<p><img src="/assets/cake-build/azure-devops-tests.png" alt="Azure DevOps Tests" /></p>

<h3 id="circleci">CircleCI</h3>

<p><code class="language-plaintext highlighter-rouge">CircleCI</code> has a few quirks when it comes to testing.</p>

<p>First it only supports the <a href="https://llg.cubic.org/docs/junit/">JUnit format</a> so I had to use the <a href="https://www.nuget.org/packages/JUnitXml.TestLogger/">JunitXml.TestLogger</a> <code class="language-plaintext highlighter-rouge">NuGet</code> package to be able to publish the test results. Then you must <a href="https://circleci.com/docs/2.0/configuration-reference/#storetestresults">place your test results within a folder named after the test framework</a> you are using if you want <code class="language-plaintext highlighter-rouge">CircleCI</code> to identify your test framework.</p>

<p>When the tests run successfully <code class="language-plaintext highlighter-rouge">CirceCI</code> will only display the slowest test (you need to navigate to <em>Test Insights</em> to see it):</p>

<p><img src="/assets/cake-build/circle-ci-test-insights-slowest-test.png" alt="Circle CI slowest test" /></p>

<p>I don‚Äôt understand the use case, I would prefer the list of tests and timing and the ability to sort them client-side.</p>

<p>The output for failed tests is much better when using a <code class="language-plaintext highlighter-rouge">JUnit</code> logger instead of trying to convert the test results:</p>

<p><img src="/assets/cake-build/circle-ci-junit-failed-test.png" alt="Circle CI failed test" /></p>

<h3 id="github-actions">GitHub Actions</h3>

<p>GitHub Actions do not support publishing test results! This is a pretty big shortcoming for a Continuous Integration system. A couple of third-party Actions are trying to fill the gap but if you‚Äôre multi-targeting or running your tests on multiple platforms expect additional complexity in you build script.</p>

<p>Visual Studio Test Results File (known colloquially as <code class="language-plaintext highlighter-rouge">TRX</code>) gave me the best output but the <a href="https://github.com/Microsoft/vstest-docs/blob/main/docs/report.md#2-trx-logger">Trx Logger</a> has limited abilities in terms of naming test results files. By default the test results file names do not include the assembly or the framework version. Using multi-targeting and the <code class="language-plaintext highlighter-rouge">LogFileName</code> parameter will result in test results files being overwritten by the last target. Using the recently introduced <code class="language-plaintext highlighter-rouge">LogFilePrefix</code> parameter doesn‚Äôt solve the issue, token expansion is not supported so you‚Äôll have to rename the files to include the assembly name and remove the trailing numbers.</p>

<p>Ultimately I had to invoke <code class="language-plaintext highlighter-rouge">dotnet test</code> for <a href="https://github.com/gabrielweyer/cake-build/blob/a7c591f847d66b3b40a82604e841a71f93580038/build.cake#L106-L159">each test project / framework combination</a>. The end result is pretty neat:</p>

<p><img src="/assets/cake-build/github-actions-report-tests.png" alt="GitHub Actions tests report" /></p>

<p>Failed tests display the test runner output and the stack trace:</p>

<p><img src="/assets/cake-build/github-actions-failed-test.png" alt="GitHub Actions failed test" /></p>

<h2 id="create-nuget-packages">Create <code class="language-plaintext highlighter-rouge">NuGet</code> packages</h2>

<p><code class="language-plaintext highlighter-rouge">.NET</code> is now leveraging the ‚Äúnew‚Äù <code class="language-plaintext highlighter-rouge">*.csproj</code> system and this means:</p>

<ul>
  <li>No more <code class="language-plaintext highlighter-rouge">packages.config</code></li>
  <li>No more <code class="language-plaintext highlighter-rouge">*.nuspec</code></li>
  <li>No more tears</li>
</ul>

<p>The references (projects and packages) and the package configuration are both contained in the <code class="language-plaintext highlighter-rouge">*.csproj</code> making it the single source of truth!</p>

<h3 id="referencing-a-project-without-turning-it-into-a-package-reference">Referencing a project without turning it into a package reference</h3>

<p>Sometimes you want to include a <code class="language-plaintext highlighter-rouge">DLL</code> in a <code class="language-plaintext highlighter-rouge">NuGet</code> package rather than add it as a package reference.</p>

<p>The <code class="language-plaintext highlighter-rouge">SuperLogic</code> project depends on the <code class="language-plaintext highlighter-rouge">ExtraLogic</code> project but we don‚Äôt want to ship <code class="language-plaintext highlighter-rouge">ExtraLogic</code> as a package. Instead we want to include <code class="language-plaintext highlighter-rouge">Contoso.Hello.ExtraLogic.dll</code> in the <code class="language-plaintext highlighter-rouge">SuperLogic</code> package directly. Currently this is not supported out of the box but the team is <a href="https://github.com/NuGet/Home/issues/6285">tracking it</a>.</p>

<p>Luckily <a href="https://github.com/NuGet/Home/issues/3891">this issue</a> provides a workaround. All the modifications will take place in <code class="language-plaintext highlighter-rouge">SuperLogic.csproj</code>.</p>

<ul>
  <li>In the <code class="language-plaintext highlighter-rouge">&lt;PropertyGroup&gt;</code> section add the following line:</li>
</ul>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;TargetsForTfmSpecificBuildOutput&gt;</span>$(TargetsForTfmSpecificBuildOutput);IncludeReferencedProjectInPackage<span class="nt">&lt;/TargetsForTfmSpecificBuildOutput&gt;</span></code></pre></figure>

<ul>
  <li>Prevent the project to be added as a package reference by making <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/csproj#includeassets-excludeassets-and-privateassets">all assets private</a>.</li>
</ul>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;ProjectReference</span> <span class="na">Include=</span><span class="s">"..\ExtraLogic\ExtraLogic.csproj"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PrivateAssets&gt;</span>all<span class="nt">&lt;/PrivateAssets&gt;</span>
<span class="nt">&lt;/ProjectReference&gt;</span></code></pre></figure>

<ul>
  <li>Finally add the target responsible of copying the <code class="language-plaintext highlighter-rouge">DLL</code>:</li>
</ul>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Target</span> <span class="na">Name=</span><span class="s">"IncludeReferencedProjectInPackage"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;ItemGroup&gt;</span>
    <span class="nt">&lt;BuildOutputInPackage</span> <span class="na">Include=</span><span class="s">"$(OutputPath)Contoso.Hello.ExtraLogic.dll"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/ItemGroup&gt;</span>
<span class="nt">&lt;/Target&gt;</span></code></pre></figure>

<p>The result is the following <code class="language-plaintext highlighter-rouge">NuGet</code> package:</p>

<p><img src="/assets/cake-build/package-version.png" alt="Package version" /></p>

<p>And the assemblies have been versioned as expected:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="nf">AssemblyFileVersion</span><span class="p">(</span><span class="s">"2.0.21-embed-symbols0001"</span><span class="p">)]</span>
<span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="nf">AssemblyInformationalVersion</span><span class="p">(</span><span class="s">"2.0.21-embed-symbols0001+9429d3dbc27c57417c07cf7c570b5e5f2267088e"</span><span class="p">)]</span>
<span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="nf">AssemblyVersion</span><span class="p">(</span><span class="s">"2.0.21.0"</span><span class="p">)]</span></code></pre></figure>

<p><strong>Note</strong>: you can also use the ‚Äúnew‚Äù <code class="language-plaintext highlighter-rouge">*.csproj</code> system for <code class="language-plaintext highlighter-rouge">NuGet</code> packages targeting older <code class="language-plaintext highlighter-rouge">.NET Framework</code> versions.</p>

<h2 id="publish-the-nuget-packages">Publish the <code class="language-plaintext highlighter-rouge">NuGet</code> packages</h2>

<p>On any branches starting with <code class="language-plaintext highlighter-rouge">features/</code>, the <code class="language-plaintext highlighter-rouge">NuGet</code> packages will be published to a pre-release feed. If the branch is <code class="language-plaintext highlighter-rouge">main</code> it‚Äôll be published to the production feed. This is handled by <code class="language-plaintext highlighter-rouge">GitHub Actions</code> in this <a href="https://github.com/gabrielweyer/cake-build/blob/a7c591f847d66b3b40a82604e841a71f93580038/.github/workflows/build.yml#L63-L68">section</a> of the configuration.</p>

<p>As this is a demo project both pre-release and production feeds are hosted by <code class="language-plaintext highlighter-rouge">MyGet</code>. For my other projects I use <code class="language-plaintext highlighter-rouge">MyGet</code> to host my <a href="https://www.myget.org/feed/Packages/gabrielweyer-pre-release">pre-release feed</a> and <code class="language-plaintext highlighter-rouge">NuGet</code> for my <a href="https://www.nuget.org/profiles/gabrielweyer">production feed</a>.</p>

<p>When publishing the packages, I‚Äôm also publishing the associated <a href="https://docs.microsoft.com/en-us/nuget/create-packages/symbol-packages-snupkg">symbols</a> to allow consumers to debug through my packages.</p>

<h2 id="create-a-github-release">Create a GitHub release</h2>

<p><code class="language-plaintext highlighter-rouge">GitHub Actions</code> also creates <code class="language-plaintext highlighter-rouge">GitHub</code> <a href="/2018/04/21/cake-build/#create-a-github-release">releases</a>. I‚Äôm using the <a href="https://cli.github.com/">GitHub CLI</a> to create a release.</p>

<p>By default the <code class="language-plaintext highlighter-rouge">GitHub CLI</code> does not use the workflow token, you have to explicitly provide it using an environment variable:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">GITHUB_TOKEN</span><span class="pi">:</span> <span class="pi">{{</span> <span class="nv">secrets.GITHUB_TOKEN</span> <span class="pi">}}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">GitHub CLI</code> relies on the shell expanding wildcards which doesn‚Äôt happen on Windows. So instead of providing:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">.<span class="se">\a</span>rtifacts<span class="se">\p</span>ackages<span class="se">\*</span></code></pre></figure>

<p>You‚Äôll need to provide:</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="p">(</span><span class="nf">Get-Item</span><span class="w"> </span><span class="o">.</span><span class="nx">\artifacts\packages\</span><span class="o">*</span><span class="p">)</span></code></pre></figure>

<p>Finally the <code class="language-plaintext highlighter-rouge">GitHub CLI</code> doesn‚Äôt allow to create a release without release notes in a non-interactive scenario. I worked around this by creating an empty file and providing it to the <code class="language-plaintext highlighter-rouge">--notes-file</code> parameter.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is one possible workflow only. I‚Äôve glossed over many details and taken some shortcuts (for example there is no support for Pull Request builds).</p>

<p>Those are the key takeaways:</p>

<ul>
  <li>Do <strong>upfront planning on how you want to handle versioning</strong>. This is the hardest part and the one that will be the hardest to fix later on. Read the <a href="https://gitversion.net/docs/">GitVersion documentation</a> carefully before making any decision.</li>
  <li>Do what works for your team. If you didn‚Äôt have any issues with auto-incrementing your builds, keep doing so. There is no point bringing additional complexity to fix a problem you don‚Äôt have.</li>
  <li>Don‚Äôt assume you‚Äôll be running on <code class="language-plaintext highlighter-rouge">Windows</code> with <code class="language-plaintext highlighter-rouge">Visual Studio Enterprise</code> installed. Adding cross-platform or other <code class="language-plaintext highlighter-rouge">IDE</code> (<code class="language-plaintext highlighter-rouge">Rider</code>, <code class="language-plaintext highlighter-rouge">Code</code>‚Ä¶) support from the start will make your life easier down the track.</li>
</ul>

:ET
<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Singleton HTTP Client &#8211; Gabriel Weyer &#8211; A somewhat technical blog</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Use a singleton HTTP Client for better performance.">
    <meta name="robots" content="all">
    <meta name="author" content="Gabriel Weyer">
    
    <meta name="keywords" content="C#">
    <link rel="canonical" href="https://gabrielweyer.net/2018/02/08/singleton-http-client/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Gabriel Weyer - A somewhat technical blog" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202202251746" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:site" content="@gabrielweyer" />
    <meta name="twitter:creator" content="@gabrielweyer" />
    
    <meta name="twitter:title" content="Singleton HTTP Client" />
    <meta name="twitter:description" content="Use a singleton HTTP Client for better performance." />
    <meta name="twitter:url" content="https://gabrielweyer.net/2018/02/08/singleton-http-client/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Gabriel Weyer<span class="site-sub-title"> &#8211; A somewhat technical blog</span></a>
      <nav class="site-nav">
        




    
    
    
    
        <a href="/about/">About</a>
    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Singleton HTTP Client</h1>
  <span class="post-meta">Feb 8, 2018</span><br>
  
  <span class="post-meta small">
  
    4 minute read
  
  </span>
</div>

<article class="post-content">
  <p>Even though the <code class="language-plaintext highlighter-rouge">class</code> <code class="language-plaintext highlighter-rouge">HttpClient</code> implements <code class="language-plaintext highlighter-rouge">IDisposable</code> it is supposed to be used as a singleton as stated in the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-2.0#Remarks">API reference</a>:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">HttpClient</code> is intended to be instantiated once and re-used throughout the life of an application. Instantiating an <code class="language-plaintext highlighter-rouge">HttpClient</code> class for every request will exhaust the number of sockets available under heavy loads. This will result in <code class="language-plaintext highlighter-rouge">SocketException</code> errors.</p>
</blockquote>

<p>The accepted best practice is to have one <code class="language-plaintext highlighter-rouge">HttpClient</code> per HTTP endpoint you’re interacting with. This will not only yield better performance it also allows to encapsulate endpoint specific logic (such as setting headers).</p>

<p>Now the question is: how do you configure your <code class="language-plaintext highlighter-rouge">IoC</code> container to resolve the expected <code class="language-plaintext highlighter-rouge">HttpClient</code> instance? This used to require a cumbersome registration but <code class="language-plaintext highlighter-rouge">.NET Core 2.1</code> will ship with the <a href="https://github.com/aspnet/HttpClientFactory">HttpClientFactory</a> making our life much easier.<!--more--></p>

<h2 id="httpclientfactory"><code class="language-plaintext highlighter-rouge">HttpClientFactory</code></h2>

<p><a href="https://www.stevejgordon.co.uk/">Steve Gordon</a> has an excellent <a href="https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore">post</a> explaining what is <code class="language-plaintext highlighter-rouge">HttpClientFactory</code> and how it works.</p>

<p><code class="language-plaintext highlighter-rouge">HttpClientFactory</code> aims to provide the following improvements:</p>

<ul>
  <li>Alleviate sockets exhaustion by reusing connection when possible</li>
  <li>Alleviate stale <code class="language-plaintext highlighter-rouge">DNS</code> records (by default <code class="language-plaintext highlighter-rouge">HttpClient</code> caches <code class="language-plaintext highlighter-rouge">DNS</code> records for its lifetime)</li>
  <li>Easily resolve an <code class="language-plaintext highlighter-rouge">HttpClient</code> instance linked to a specific HTTP endpoint</li>
</ul>

<p>What if you can’t use <code class="language-plaintext highlighter-rouge">.NET Core</code> or can’t update? Fear not, we can achieve tomorrow’s dream with today’s tools (most of it anyway).</p>

<h2 id="associate-an-httpclient-instance-with-the-service-using-it">Associate an <code class="language-plaintext highlighter-rouge">HttpClient</code> instance with the service using it</h2>

<p><code class="language-plaintext highlighter-rouge">HttpClient</code> instances communicating with a specific HTTP endpoint tend to have dedicated settings such as an <code class="language-plaintext highlighter-rouge">Authorization</code> header, default request headers (<code class="language-plaintext highlighter-rouge">Accept</code> for example), maybe a <code class="language-plaintext highlighter-rouge">HMAC</code>… I tend to encapsulate those settings in a <code class="language-plaintext highlighter-rouge">class</code> to decouple the settings’s source from the consummer.</p>

<p>Let’s imagine that we’re integrating with a fictitious company called <em>Contoso</em>. The integration takes place via an HTTP API and our contact at Contoso gave us a bearer token that needs to be set on the <code class="language-plaintext highlighter-rouge">Authorization</code> header.</p>

<p>The first step is to create a <code class="language-plaintext highlighter-rouge">POCO</code> modelizing the settings:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ContosoSettings</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Uri</span> <span class="n">BaseAddress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">BearerToken</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">HttpClient</code> makes writing tests harder. Developers tend to derive from <code class="language-plaintext highlighter-rouge">HttpMessageHandler</code> and provide an implementation allowing them to assert the requests issued by the <code class="language-plaintext highlighter-rouge">HttpClient</code>. I prefer to introduce an interface called <code class="language-plaintext highlighter-rouge">IHttpClient</code> exposing a single method to handle <code class="language-plaintext highlighter-rouge">HTTP</code> traffic:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IHttpClient</span>
<span class="p">{</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="nf">SendAsync</span><span class="p">(</span><span class="n">HttpRequestMessage</span> <span class="n">request</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>We then implement the <code class="language-plaintext highlighter-rouge">ContosoHttpClient</code> that will be dedicated to communicating with the <code class="language-plaintext highlighter-rouge">Contoso</code> API:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ContosoHttpClient</span> <span class="p">:</span> <span class="n">HttpClient</span><span class="p">,</span> <span class="n">IHttpClient</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">ContosoHttpClient</span><span class="p">(</span><span class="n">ContosoSettings</span> <span class="n">settings</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">BaseAddress</span> <span class="p">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">;</span>
        <span class="n">DefaultRequestHeaders</span><span class="p">.</span><span class="n">Authorization</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AuthenticationHeaderValue</span><span class="p">(</span><span class="s">"Bearer"</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="n">BearerToken</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And finally we registers the <code class="language-plaintext highlighter-rouge">Type</code>s in the <code class="language-plaintext highlighter-rouge">IoC</code> container:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">const</span> <span class="kt">string</span> <span class="n">contosoHttpClientAutofacKeyName</span> <span class="p">=</span> <span class="s">"ContosoHttpClient"</span><span class="p">;</span>

<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ContosoHttpClient</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Named</span><span class="p">(</span><span class="n">contosoHttpClientAutofacKeyName</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IHttpClient</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">SingleInstance</span><span class="p">();</span>

<span class="n">builder</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&lt;</span><span class="n">ContosoClient</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">WithParameter</span><span class="p">(</span><span class="k">new</span> <span class="nf">ResolvedParameter</span><span class="p">(</span>
        <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">pi</span><span class="p">.</span><span class="n">ParameterType</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IHttpClient</span><span class="p">),</span>
        <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">ResolveNamed</span><span class="p">&lt;</span><span class="n">IHttpClient</span><span class="p">&gt;(</span><span class="n">ContosoHttpClientAutofacKeyName</span><span class="p">)))</span>
    <span class="p">.</span><span class="nf">AsImplementedInterfaces</span><span class="p">().</span><span class="nf">InstancePerRequest</span><span class="p">();</span>

<span class="c1">// Abbreviated: resolve and register ContosoSettings (from Web.config, appsettings.json, CSV, volumen...)</span></code></pre></figure>

<p>This snippet is using <code class="language-plaintext highlighter-rouge">Autofac</code> <a href="http://autofaccn.readthedocs.io/en/latest/advanced/keyed-services.html#named-services">named service</a>. Using a <code class="language-plaintext highlighter-rouge">named service</code> this way has several benefits:</p>

<ul>
  <li>If someone registered another <code class="language-plaintext highlighter-rouge">IHttpClient</code> that is supposed to be used everywhere else we will not override the registration for all the other services while still retrieving an instance of <code class="language-plaintext highlighter-rouge">ContosoHttpClient</code> when resolving <code class="language-plaintext highlighter-rouge">IContosoClient</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">named service</code> is an implementation details that only the <code class="language-plaintext highlighter-rouge">IoC</code> container knows about.</li>
</ul>

<h2 id="solve-stale-dns-records">Solve stale DNS records</h2>

<p>Let’s say you’re interacting with an API hosted at <code class="language-plaintext highlighter-rouge">https://api.contoso.com</code>, <code class="language-plaintext highlighter-rouge">HttpClient</code> will first have to resolve the domain name to an <code class="language-plaintext highlighter-rouge">IP</code> thanks to a <code class="language-plaintext highlighter-rouge">DNS</code> server. But what happens if the <code class="language-plaintext highlighter-rouge">DNS</code> record is updated and the domain name now resolves to another <code class="language-plaintext highlighter-rouge">IP</code>? If you are using a transient <code class="language-plaintext highlighter-rouge">HttpClient</code> you’ll be fine but if you’re using a singleton instance (as you should) <code class="language-plaintext highlighter-rouge">Exception</code>s will start to shoot up in your monitoring system. Should we stop calling APIs, or maybe rewrite everything in <code class="language-plaintext highlighter-rouge">Go</code>?</p>

<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.servicepoint.connectionleasetimeout?view=netframework-4.7.1#System_Net_ServicePoint_ConnectionLeaseTimeout">ConnectionLeaseTimeout</a> property can solve this situation nicely for us:</p>

<blockquote>
  <p>A <code class="language-plaintext highlighter-rouge">Int32</code> that specifies the number of <strong>milliseconds</strong> that an active <code class="language-plaintext highlighter-rouge">ServicePoint</code> connection remains open. <strong>The default is <code class="language-plaintext highlighter-rouge">-1</code>, which allows an active <code class="language-plaintext highlighter-rouge">ServicePoint</code> connection to stay connected indefinitely</strong>. Set this property to <code class="language-plaintext highlighter-rouge">0</code> to force <code class="language-plaintext highlighter-rouge">ServicePoint</code> connections to close after servicing a request.</p>
</blockquote>

<p>This is how you set it:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">apiUri</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="s">"https://api.contoso.com"</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">sp</span> <span class="p">=</span> <span class="n">ServicePointManager</span><span class="p">.</span><span class="nf">FindServicePoint</span><span class="p">(</span><span class="n">apiUri</span><span class="p">);</span>
<span class="n">sp</span><span class="p">.</span><span class="n">ConnectionLeaseTimeout</span> <span class="p">=</span> <span class="m">60</span><span class="p">*</span><span class="m">1000</span><span class="p">;</span></code></pre></figure>

<p>In the previous snippet I’m keeping the connection opened for a minute which seems like a good trade-off.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I haven’t looked at the implementation of <code class="language-plaintext highlighter-rouge">HttpClientFactory</code> yet but I suspect the end result will be fairly similar to what I demonstrated above. If you still have doubts about using a singleton <code class="language-plaintext highlighter-rouge">HttpClient</code> I recommend you to perf test it. At a previous customer I developped an API that was calling other HTTP endpoints, I increased the throughput by a factor of <code class="language-plaintext highlighter-rouge">10</code> by changing a single thing: I made the <code class="language-plaintext highlighter-rouge">HttpClient</code> a singleton rather than a per-request scope.</p>


</article>













      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Gabriel Weyer. <a href="https://github.com/johnotander/pixyll">Theme</a> crafted with &lt;3 by <a href="https://twitter.com/4lpine">John Otander</a>.
    </small>
  </div>
</footer>


</body>
</html>
